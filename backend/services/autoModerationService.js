import { Report, ModerationAction, Utilisateur } from '../models/index.js';
import { Op } from 'sequelize';

/**
 * Service de ModÃ©ration Automatique
 * GÃ©nÃ¨re des signalements automatiques basÃ©s sur les comportements suspects
 */

class AutoModerationService {
  
  /**
   * CrÃ©er un signalement automatique
   */
  async createAutoReport(reportData) {
    try {
      const {
        userId,
        type,
        reason,
        severity = 'medium',
        evidence = {},
        fileId = null
      } = reportData;

      // VÃ©rifier si l'utilisateur existe
      const user = await Utilisateur.findByPk(userId);
      if (!user) {
        console.error(`âŒ Utilisateur ${userId} non trouvÃ© pour signalement automatique`);
        return null;
      }

      // VÃ©rifier s'il n'y a pas dÃ©jÃ  un signalement similaire rÃ©cent
      const existingReport = await this.checkDuplicateReport(userId, type);
      if (existingReport) {
        console.log(`âš ï¸  Signalement similaire dÃ©jÃ  existant pour ${userId}, type: ${type}`);
        return existingReport;
      }

      // CrÃ©er le signalement automatique
      const report = await Report.create({
        reporter_id: null, // Signalement systÃ¨me (pas d'utilisateur rapporteur)
        reported_user_id: userId,
        file_id: fileId,
        type: this.mapTypeToReportType(type),
        reason: reason,
        status: 'pending',
        source: 'automatic', // ðŸŽ¯ CORRECTION : Marquer comme automatique
        evidence: JSON.stringify(evidence), // ðŸ“ Ajouter les preuves
        admin_id: null,
        admin_action: null,
        resolved_at: null,
        metadata: {
          autoGenerated: true,
          systemType: type,
          severity: severity,
          evidence: evidence,
          generatedAt: new Date().toISOString(),
          riskScore: evidence.riskScore || 0
        }
      });

      console.log(`ðŸ¤– Signalement automatique crÃ©Ã©: ${report.id} pour utilisateur ${userId}`);
      
      // Notifier l'admin selon la gravitÃ©
      await this.notifyAdmin(report, severity);
      
      // Prendre des actions automatiques si nÃ©cessaire
      await this.takeAutomaticActions(report, severity, evidence);

      return report;
    } catch (error) {
      console.error('âŒ Erreur lors de la crÃ©ation du signalement automatique:', error);
      throw error;
    }
  }

  /**
   * VÃ©rifier s'il existe dÃ©jÃ  un signalement similaire rÃ©cent
   */
  async checkDuplicateReport(userId, systemType) {
    try {
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
      
      const existingReport = await Report.findOne({
        where: {
          reported_user_id: userId,
          status: 'pending',
          created_at: {
            [Op.gte]: oneHourAgo
          },
          metadata: {
            systemType: systemType
          }
        }
      });

      return existingReport;
    } catch (error) {
      console.error('âŒ Erreur lors de la vÃ©rification des doublons:', error);
      return null;
    }
  }

  /**
   * Mapper les types systÃ¨me vers les types de signalement
   */
  mapTypeToReportType(systemType) {
    const typeMapping = {
      'system_upload_abuse': 'spam',
      'system_behavior_abuse': 'inappropriate',
      'system_api_abuse': 'spam',
      'system_critical_behavior': 'inappropriate',
      'system_suspicious_behavior': 'other',
      'system_security_risk': 'inappropriate'
    };

    return typeMapping[systemType] || 'other';
  }

  /**
   * Notifier l'administrateur selon la gravitÃ©
   */
  async notifyAdmin(report, severity) {
    try {
      // TODO: ImplÃ©menter les notifications (email, Slack, etc.)
      
      const notificationMessage = this.generateNotificationMessage(report, severity);
      
      console.log(`ðŸ“§ Notification admin [${severity.toUpperCase()}]: ${notificationMessage}`);
      
      // En production, envoyer email/SMS/Slack selon la gravitÃ©
      if (severity === 'critical') {
        console.log('ðŸš¨ ALERTE CRITIQUE - Notification immÃ©diate requise');
        // await this.sendCriticalAlert(report);
      } else if (severity === 'high') {
        console.log('âš ï¸  ALERTE Ã‰LEVÃ‰E - Notification prioritaire');
        // await this.sendHighPriorityAlert(report);
      } else {
        console.log('ðŸ“‹ ALERTE STANDARD - Notification normale');
        // await this.sendStandardAlert(report);
      }
      
    } catch (error) {
      console.error('âŒ Erreur lors de la notification admin:', error);
    }
  }

  /**
   * GÃ©nÃ©rer le message de notification
   */
  generateNotificationMessage(report, severity) {
    const user = report.reported_user_id;
    const type = report.metadata?.systemType || 'unknown';
    const riskScore = report.metadata?.evidence?.riskScore || 0;
    
    return `Signalement automatique [${severity}]: Utilisateur ${user} - ${type} (Score: ${riskScore}/100)`;
  }

  /**
   * Prendre des actions automatiques selon la gravitÃ©
   */
  async takeAutomaticActions(report, severity, evidence) {
    try {
      const userId = report.reported_user_id;
      const riskScore = evidence.riskScore || 0;

      // Actions selon le score de risque
      if (riskScore >= 80) {
        // Score trÃ¨s critique : Suspension temporaire automatique
        await this.createAutoSuspension(userId, report.id, '24 heures', 'Score de risque critique (>80)');
        
      } else if (riskScore >= 60) {
        // Score Ã©levÃ© : Limitation sÃ©vÃ¨re
        await this.createAutoWarning(userId, report.id, 'Comportement automatique dÃ©tectÃ© - Surveillance renforcÃ©e');
        
      } else if (riskScore >= 40) {
        // Score modÃ©rÃ© : Avertissement automatique
        await this.createAutoWarning(userId, report.id, 'ActivitÃ© suspecte dÃ©tectÃ©e - Veuillez respecter les conditions d\'utilisation');
      }

      console.log(`âš™ï¸  Actions automatiques appliquÃ©es pour utilisateur ${userId} (score: ${riskScore})`);
      
    } catch (error) {
      console.error('âŒ Erreur lors des actions automatiques:', error);
    }
  }

  /**
   * CrÃ©er un avertissement automatique
   */
  async createAutoWarning(userId, reportId, reason) {
    try {
      // Trouver un admin systÃ¨me pour attribuer l'action
      const systemAdmin = await this.getSystemAdmin();
      
      const warning = await ModerationAction.create({
        user_id: userId,
        admin_id: systemAdmin.id,
        report_id: reportId,
        action_type: 'warning',
        reason: `[AUTOMATIQUE] ${reason}`,
        duration: null,
        start_date: new Date(),
        end_date: null,
        is_active: true,
        metadata: {
          autoGenerated: true,
          systemAction: true,
          generatedAt: new Date().toISOString()
        }
      });

      console.log(`âš ï¸  Avertissement automatique crÃ©Ã©: ${warning.id} pour utilisateur ${userId}`);
      return warning;
      
    } catch (error) {
      console.error('âŒ Erreur lors de la crÃ©ation de l\'avertissement automatique:', error);
      throw error;
    }
  }

  /**
   * CrÃ©er une suspension automatique
   */
  async createAutoSuspension(userId, reportId, duration, reason) {
    try {
      const systemAdmin = await this.getSystemAdmin();
      
      // Calculer la durÃ©e en jours
      const durationDays = this.parseDuration(duration);
      const endDate = new Date(Date.now() + durationDays * 24 * 60 * 60 * 1000);
      
      const suspension = await ModerationAction.create({
        user_id: userId,
        admin_id: systemAdmin.id,
        report_id: reportId,
        action_type: 'suspension',
        reason: `[AUTOMATIQUE] ${reason}`,
        duration: durationDays,
        start_date: new Date(),
        end_date: endDate,
        is_active: true,
        metadata: {
          autoGenerated: true,
          systemAction: true,
          generatedAt: new Date().toISOString(),
          originalDuration: duration
        }
      });

      console.log(`ðŸš« Suspension automatique crÃ©Ã©e: ${suspension.id} pour utilisateur ${userId} (${duration})`);
      return suspension;
      
    } catch (error) {
      console.error('âŒ Erreur lors de la crÃ©ation de la suspension automatique:', error);
      throw error;
    }
  }

  /**
   * Obtenir l'admin systÃ¨me pour les actions automatiques
   */
  async getSystemAdmin() {
    try {
      // Chercher un admin systÃ¨me ou crÃ©er un compte systÃ¨me
      let systemAdmin = await Utilisateur.findOne({
        where: {
          email: 'system@hifadhui.site',
          role: 'admin'
        }
      });

      if (!systemAdmin) {
        // CrÃ©er un compte admin systÃ¨me si nÃ©cessaire
        systemAdmin = await Utilisateur.create({
          username: 'SystÃ¨me Hifadhui',
          email: 'system@hifadhui.site',
          password: 'system_account_no_login',
          role: 'admin',
          provider: 'system',
          metadata: {
            systemAccount: true,
            description: 'Compte systÃ¨me pour les actions automatiques'
          }
        });
        
        console.log('ðŸ¤– Compte admin systÃ¨me crÃ©Ã© pour les actions automatiques');
      }

      return systemAdmin;
      
    } catch (error) {
      console.error('âŒ Erreur lors de la rÃ©cupÃ©ration de l\'admin systÃ¨me:', error);
      throw error;
    }
  }

  /**
   * Parser la durÃ©e en jours
   */
  parseDuration(duration) {
    const durationMap = {
      '15 minutes': 0.01,
      '1 heure': 0.04,
      '6 heures': 0.25,
      '24 heures': 1,
      '3 jours': 3,
      '7 jours': 7,
      '14 jours': 14,
      '30 jours': 30
    };

    return durationMap[duration] || 1;
  }

  /**
   * Obtenir les statistiques des signalements automatiques
   */
  async getAutoReportStats(timeframe = '24h') {
    try {
      const timeframeDates = this.getTimeframeDate(timeframe);
      
      const stats = await Report.findAll({
        where: {
          created_at: {
            [Op.gte]: timeframeDates.start
          },
          metadata: {
            autoGenerated: true
          }
        },
        attributes: ['type', 'status', 'metadata'],
        raw: true
      });

      const summary = {
        total: stats.length,
        byType: {},
        byStatus: {},
        bySeverity: {},
        avgRiskScore: 0
      };

      let totalRiskScore = 0;
      let riskScoreCount = 0;

      stats.forEach(report => {
        // Par type
        summary.byType[report.type] = (summary.byType[report.type] || 0) + 1;
        
        // Par statut
        summary.byStatus[report.status] = (summary.byStatus[report.status] || 0) + 1;
        
        // Par gravitÃ©
        const severity = report.metadata?.severity || 'unknown';
        summary.bySeverity[severity] = (summary.bySeverity[severity] || 0) + 1;
        
        // Score de risque moyen
        const riskScore = report.metadata?.evidence?.riskScore;
        if (riskScore) {
          totalRiskScore += riskScore;
          riskScoreCount++;
        }
      });

      if (riskScoreCount > 0) {
        summary.avgRiskScore = Math.round(totalRiskScore / riskScoreCount);
      }

      return summary;
      
    } catch (error) {
      console.error('âŒ Erreur lors de la rÃ©cupÃ©ration des stats:', error);
      throw error;
    }
  }

  /**
   * Obtenir la date de dÃ©but selon la pÃ©riode
   */
  getTimeframeDate(timeframe) {
    const now = new Date();
    let start;

    switch (timeframe) {
      case '1h':
        start = new Date(now.getTime() - 60 * 60 * 1000);
        break;
      case '24h':
        start = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case '7d':
        start = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case '30d':
        start = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      default:
        start = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    }

    return { start, end: now };
  }

  /**
   * RÃ©soudre automatiquement les anciens signalements
   */
  async resolveOldReports() {
    try {
      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      
      // 1) RÃ©cupÃ©rer les signalements automatiques en attente crÃ©Ã©s il y a plus de 7 jours
      //    On Ã©vite de mettre un objet JSON complexe (avec tableau) dans where.metadata
      //    pour ne pas provoquer d'erreur Sequelize "Invalid value { autoGenerated: true }".
      const candidates = await Report.findAll({
        where: {
          status: 'pending',
          created_at: {
            [Op.lt]: sevenDaysAgo
          }
        },
        attributes: ['id', 'metadata']
      });

      // 2) Filtrer cÃ´tÃ© JS : uniquement les signalements automatiques
      //    avec une sÃ©vÃ©ritÃ© "low" ou "medium" dans metadata
      const targetIds = candidates
        .filter((report) => {
          const meta = report.metadata || {};
          const isAuto = meta.autoGenerated === true;
          const severity = meta.severity;
          return isAuto && (severity === 'low' || severity === 'medium');
        })
        .map((report) => report.id);

      if (targetIds.length === 0) {
        console.log('ðŸ§¹ Aucun ancien signalement automatique Ã  rÃ©soudre');
        return 0;
      }

      // 3) Mettre Ã  jour uniquement les IDs filtrÃ©s
      const [updatedCount] = await Report.update(
        {
          status: 'resolved',
          admin_action: '[AUTOMATIQUE] RÃ©solu automatiquement aprÃ¨s 7 jours',
          resolved_at: new Date()
        },
        {
          where: {
            id: targetIds
          }
        }
      );

      console.log(`ðŸ§¹ ${updatedCount} anciens signalements automatiques rÃ©solus`);
      return updatedCount;
      
    } catch (error) {
      console.error('âŒ Erreur lors de la rÃ©solution automatique:', error);
      throw error;
    }
  }
}

// CrÃ©er une instance singleton
export const autoModerationService = new AutoModerationService();

// Programmer le nettoyage automatique (toutes les 6 heures)
setInterval(() => {
  autoModerationService.resolveOldReports().catch(console.error);
}, 6 * 60 * 60 * 1000);

export default autoModerationService;
