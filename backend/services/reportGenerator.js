import { Report, ModerationAction, Utilisateur, File } from '../models/index.js';
import { Op } from 'sequelize';
import fs from 'fs/promises';
import path from 'path';

/**
 * Service de G√©n√©ration de Rapports
 * G√©n√®re des rapports d√©taill√©s sur les activit√©s de mod√©ration
 */

class ReportGenerator {
  
  /**
   * G√©n√©rer un rapport de mod√©ration complet
   */
  async generateModerationReport(options = {}) {
    try {
      const {
        startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // 30 jours par d√©faut
        endDate = new Date(),
        includeAutoReports = true,
        includeManualReports = true,
        format = 'json' // json, csv, pdf
      } = options;

      console.log(`üìä G√©n√©ration du rapport de mod√©ration (${startDate.toISOString()} - ${endDate.toISOString()})`);

      // Collecter toutes les donn√©es
      const data = await this.collectModerationData(startDate, endDate, includeAutoReports, includeManualReports);
      
      // Analyser les donn√©es
      const analysis = this.analyzeModerationData(data);
      
      // G√©n√©rer le rapport selon le format
      const report = {
        metadata: {
          generatedAt: new Date().toISOString(),
          period: {
            start: startDate.toISOString(),
            end: endDate.toISOString(),
            durationDays: Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000))
          },
          includeAutoReports,
          includeManualReports,
          format
        },
        summary: analysis.summary,
        trends: analysis.trends,
        details: data,
        recommendations: this.generateRecommendations(analysis)
      };

      // Sauvegarder le rapport
      const reportId = await this.saveReport(report, format);
      
      console.log(`‚úÖ Rapport de mod√©ration g√©n√©r√©: ${reportId}`);
      return { reportId, report };
      
    } catch (error) {
      console.error('‚ùå Erreur lors de la g√©n√©ration du rapport:', error);
      throw error;
    }
  }

  /**
   * Collecter les donn√©es de mod√©ration
   */
  async collectModerationData(startDate, endDate, includeAutoReports, includeManualReports) {
    try {
      const whereConditions = {
        created_at: {
          [Op.between]: [startDate, endDate]
        }
      };

      // Filtrer par type de signalement
      if (includeAutoReports && !includeManualReports) {
        whereConditions.metadata = {
          autoGenerated: true
        };
      } else if (!includeAutoReports && includeManualReports) {
        whereConditions.metadata = {
          autoGenerated: { [Op.not]: true }
        };
      }

      // R√©cup√©rer les signalements
      const reports = await Report.findAll({
        where: whereConditions,
        include: [
          {
            model: Utilisateur,
            as: 'reportedUser',
            attributes: ['id', 'username', 'email', 'created_at', 'role']
          },
          {
            model: Utilisateur,
            as: 'reporter',
            attributes: ['id', 'username', 'email'],
            required: false
          },
          {
            model: Utilisateur,
            as: 'admin',
            attributes: ['id', 'username', 'email'],
            required: false
          },
          {
            model: File,
            as: 'file',
            attributes: ['id', 'nom_fichier', 'type_fichier', 'taille'],
            required: false
          }
        ],
        order: [['created_at', 'DESC']]
      });

      // R√©cup√©rer les actions de mod√©ration
      const moderationActions = await ModerationAction.findAll({
        where: {
          created_at: {
            [Op.between]: [startDate, endDate]
          }
        },
        include: [
          {
            model: Utilisateur,
            as: 'user',
            attributes: ['id', 'username', 'email']
          },
          {
            model: Utilisateur,
            as: 'admin',
            attributes: ['id', 'username', 'email']
          },
          {
            model: Report,
            as: 'report',
            attributes: ['id', 'type', 'reason'],
            required: false
          }
        ],
        order: [['created_at', 'DESC']]
      });

      return {
        reports: reports.map(r => r.toJSON()),
        moderationActions: moderationActions.map(a => a.toJSON()),
        period: { startDate, endDate }
      };
      
    } catch (error) {
      console.error('‚ùå Erreur lors de la collecte des donn√©es:', error);
      throw error;
    }
  }

  /**
   * Analyser les donn√©es de mod√©ration
   */
  analyzeModerationData(data) {
    try {
      const { reports, moderationActions } = data;
      
      // Statistiques g√©n√©rales
      const summary = {
        totalReports: reports.length,
        autoReports: reports.filter(r => r.metadata?.autoGenerated).length,
        manualReports: reports.filter(r => !r.metadata?.autoGenerated).length,
        resolvedReports: reports.filter(r => r.status === 'resolved').length,
        pendingReports: reports.filter(r => r.status === 'pending').length,
        dismissedReports: reports.filter(r => r.status === 'dismissed').length,
        
        totalActions: moderationActions.length,
        warnings: moderationActions.filter(a => a.action_type === 'warning').length,
        suspensions: moderationActions.filter(a => a.action_type === 'suspension').length,
        deletions: moderationActions.filter(a => a.action_type === 'deletion').length,
        
        avgResponseTime: this.calculateAverageResponseTime(reports),
        topReportedUsers: this.getTopReportedUsers(reports),
        reportsByType: this.groupByField(reports, 'type'),
        actionsByType: this.groupByField(moderationActions, 'action_type')
      };

      // Analyse des tendances
      const trends = {
        dailyReports: this.getDailyTrends(reports, 'created_at'),
        dailyActions: this.getDailyTrends(moderationActions, 'created_at'),
        simpleStats: this.getSimpleStats(reports),
        responseTimeEvolution: this.getResponseTimeEvolution(reports)
      };

      return { summary, trends };
      
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'analyse des donn√©es:', error);
      throw error;
    }
  }

  /**
   * Calculer le temps de r√©ponse moyen
   */
  calculateAverageResponseTime(reports) {
    const resolvedReports = reports.filter(r => r.resolved_at && r.created_at);
    
    if (resolvedReports.length === 0) return 0;
    
    const totalResponseTime = resolvedReports.reduce((sum, report) => {
      const responseTime = new Date(report.resolved_at) - new Date(report.created_at);
      return sum + responseTime;
    }, 0);
    
    const avgMs = totalResponseTime / resolvedReports.length;
    return Math.round(avgMs / (1000 * 60 * 60)); // Convertir en heures
  }

  /**
   * Obtenir les utilisateurs les plus signal√©s
   */
  getTopReportedUsers(reports) {
    const userCounts = {};
    
    reports.forEach(report => {
      const userId = report.reported_user_id;
      if (!userCounts[userId]) {
        userCounts[userId] = {
          userId,
          username: report.reportedUser?.username || 'Inconnu',
          email: report.reportedUser?.email || 'Inconnu',
          count: 0,
          autoReports: 0,
          manualReports: 0
        };
      }
      
      userCounts[userId].count++;
      if (report.metadata?.autoGenerated) {
        userCounts[userId].autoReports++;
      } else {
        userCounts[userId].manualReports++;
      }
    });
    
    return Object.values(userCounts)
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
  }

  /**
   * Grouper par champ
   */
  groupByField(items, field) {
    const groups = {};
    
    items.forEach(item => {
      const value = item[field] || 'unknown';
      groups[value] = (groups[value] || 0) + 1;
    });
    
    return groups;
  }

  /**
   * Obtenir les tendances quotidiennes
   */
  getDailyTrends(items, dateField) {
    const dailyCounts = {};
    
    items.forEach(item => {
      const date = new Date(item[dateField]).toISOString().split('T')[0];
      dailyCounts[date] = (dailyCounts[date] || 0) + 1;
    });
    
    // Convertir en tableau tri√©
    return Object.entries(dailyCounts)
      .map(([date, count]) => ({ date, count }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }

  /**
   * Statistiques simplifi√©es des signalements
   */
  getSimpleStats(reports) {
    return {
      total: reports.length,
      automatic: reports.filter(r => r.source === 'automatic').length,
      manual: reports.filter(r => r.source === 'manual').length,
      resolved: reports.filter(r => r.status === 'resolved').length
    };
  }

  /**
   * √âvolution du temps de r√©ponse
   */
  getResponseTimeEvolution(reports) {
    const resolvedReports = reports
      .filter(r => r.resolved_at && r.created_at)
      .map(r => ({
        date: new Date(r.created_at).toISOString().split('T')[0],
        responseTime: (new Date(r.resolved_at) - new Date(r.created_at)) / (1000 * 60 * 60) // heures
      }));
    
    // Grouper par date et calculer la moyenne
    const dailyAvg = {};
    resolvedReports.forEach(({ date, responseTime }) => {
      if (!dailyAvg[date]) {
        dailyAvg[date] = { total: 0, count: 0 };
      }
      dailyAvg[date].total += responseTime;
      dailyAvg[date].count++;
    });
    
    return Object.entries(dailyAvg)
      .map(([date, { total, count }]) => ({
        date,
        avgResponseTime: Math.round(total / count * 100) / 100
      }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }

  /**
   * G√©n√©rer des recommandations
   */
  generateRecommendations(analysis) {
    const recommendations = [];
    const { summary, trends } = analysis;
    
    // Recommandations bas√©es sur le volume
    if (summary.pendingReports > summary.resolvedReports) {
      recommendations.push({
        type: 'workload',
        priority: 'high',
        title: 'Arri√©r√© de signalements',
        description: `${summary.pendingReports} signalements en attente vs ${summary.resolvedReports} r√©solus`,
        action: 'Augmenter la capacit√© de traitement ou automatiser davantage'
      });
    }
    
    // Recommandations bas√©es sur le temps de r√©ponse
    if (summary.avgResponseTime > 24) {
      recommendations.push({
        type: 'performance',
        priority: 'medium',
        title: 'Temps de r√©ponse √©lev√©',
        description: `Temps de r√©ponse moyen: ${summary.avgResponseTime}h`,
        action: 'Optimiser le processus de traitement des signalements'
      });
    }
    
    // Recommandations bas√©es sur les utilisateurs r√©cidivistes
    const topUser = summary.topReportedUsers[0];
    if (topUser && topUser.count > 5) {
      recommendations.push({
        type: 'user_management',
        priority: 'high',
        title: 'Utilisateur r√©cidiviste d√©tect√©',
        description: `${topUser.username} a √©t√© signal√© ${topUser.count} fois`,
        action: 'Envisager une action de mod√©ration plus stricte'
      });
    }
    
    // Recommandations bas√©es sur les tendances
    const recentTrend = trends.dailyReports.slice(-7);
    const avgRecent = recentTrend.reduce((sum, day) => sum + day.count, 0) / 7;
    const olderTrend = trends.dailyReports.slice(-14, -7);
    const avgOlder = olderTrend.reduce((sum, day) => sum + day.count, 0) / 7;
    
    if (avgRecent > avgOlder * 1.5) {
      recommendations.push({
        type: 'trend',
        priority: 'medium',
        title: 'Augmentation des signalements',
        description: `+${Math.round((avgRecent - avgOlder) / avgOlder * 100)}% cette semaine`,
        action: 'Surveiller de pr√®s et identifier les causes'
      });
    }
    
    return recommendations;
  }

  /**
   * Sauvegarder le rapport
   */
  async saveReport(report, format) {
    try {
      const reportId = `moderation_report_${Date.now()}`;
      const reportsDir = path.join(process.cwd(), 'reports');
      
      // Cr√©er le dossier s'il n'existe pas
      try {
        await fs.access(reportsDir);
      } catch {
        await fs.mkdir(reportsDir, { recursive: true });
      }
      
      let filePath;
      let content;
      
      switch (format) {
        case 'json':
          filePath = path.join(reportsDir, `${reportId}.json`);
          content = JSON.stringify(report, null, 2);
          break;
          
        case 'csv':
          filePath = path.join(reportsDir, `${reportId}.csv`);
          content = this.convertToCSV(report);
          break;
          
        default:
          filePath = path.join(reportsDir, `${reportId}.json`);
          content = JSON.stringify(report, null, 2);
      }
      
      await fs.writeFile(filePath, content, 'utf8');
      
      console.log(`üíæ Rapport sauvegard√©: ${filePath}`);
      return reportId;
      
    } catch (error) {
      console.error('‚ùå Erreur lors de la sauvegarde:', error);
      throw error;
    }
  }

  /**
   * Convertir en CSV
   */
  convertToCSV(report) {
    const { details } = report;
    let csv = '';
    
    // En-t√™tes pour les signalements
    csv += 'Type,ID,Date,Utilisateur,Raison,Statut,Score Risque,Auto-g√©n√©r√©\n';
    
    // Donn√©es des signalements
    details.reports.forEach(r => {
      const riskScore = r.metadata?.evidence?.riskScore || 0;
      const autoGenerated = r.metadata?.autoGenerated ? 'Oui' : 'Non';
      
      csv += `"${r.type}","${r.id}","${r.created_at}","${r.reportedUser?.username || 'Inconnu'}","${r.reason || ''}","${r.status}","${riskScore}","${autoGenerated}"\n`;
    });
    
    return csv;
  }

  /**
   * G√©n√©rer un rapport de performance syst√®me
   */
  async generateSystemPerformanceReport() {
    try {
      const now = new Date();
      const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);
      
      // Collecter les m√©triques syst√®me
      const metrics = {
        timestamp: now.toISOString(),
        period: '24h',
        autoModeration: {
          reportsGenerated: await this.countAutoReports(last24h, now),
          actionsExecuted: await this.countAutoActions(last24h, now),
          avgRiskScore: await this.getAverageRiskScore(last24h, now),
          falsePositives: await this.estimateFalsePositives(last24h, now)
        },
        performance: {
          responseTime: await this.getSystemResponseTime(),
          memoryUsage: process.memoryUsage(),
          uptime: process.uptime()
        }
      };
      
      return metrics;
      
    } catch (error) {
      console.error('‚ùå Erreur rapport performance:', error);
      throw error;
    }
  }

  /**
   * Compter les signalements automatiques
   */
  async countAutoReports(startDate, endDate) {
    return await Report.count({
      where: {
        created_at: { [Op.between]: [startDate, endDate] },
        metadata: { autoGenerated: true }
      }
    });
  }

  /**
   * Compter les actions automatiques
   */
  async countAutoActions(startDate, endDate) {
    return await ModerationAction.count({
      where: {
        created_at: { [Op.between]: [startDate, endDate] },
        metadata: { autoGenerated: true }
      }
    });
  }

  /**
   * Obtenir le score de risque moyen
   */
  async getAverageRiskScore(startDate, endDate) {
    const reports = await Report.findAll({
      where: {
        created_at: { [Op.between]: [startDate, endDate] },
        metadata: { autoGenerated: true }
      },
      attributes: ['metadata']
    });
    
    const scores = reports
      .map(r => r.metadata?.evidence?.riskScore)
      .filter(score => score !== undefined);
    
    if (scores.length === 0) return 0;
    
    return Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
  }

  /**
   * Estimer les faux positifs
   */
  async estimateFalsePositives(startDate, endDate) {
    const dismissedAutoReports = await Report.count({
      where: {
        created_at: { [Op.between]: [startDate, endDate] },
        status: 'dismissed',
        metadata: { autoGenerated: true }
      }
    });
    
    const totalAutoReports = await this.countAutoReports(startDate, endDate);
    
    return totalAutoReports > 0 ? Math.round((dismissedAutoReports / totalAutoReports) * 100) : 0;
  }

  /**
   * Obtenir le temps de r√©ponse syst√®me
   */
  async getSystemResponseTime() {
    // Simuler une mesure de performance
    const start = Date.now();
    await Report.findOne({ limit: 1 });
    const end = Date.now();
    
    return end - start;
  }
}

// Cr√©er une instance singleton
export const reportGenerator = new ReportGenerator();

export default reportGenerator;
