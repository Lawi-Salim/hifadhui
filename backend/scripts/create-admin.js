import { Sequelize } from 'sequelize';
import pg from 'pg';
import bcrypt from 'bcryptjs';

// D√©tection automatique de l'environnement
const isProduction = process.env.NODE_ENV === 'production' || 
                    process.env.VERCEL === '1' || 
                    (process.env.DB_HOST && process.env.DB_HOST.includes('supabase.com'));

// Configuration de base de donn√©es directe pour Vercel (priorit√© √† DATABASE_URL)
const baseOptions = {
  dialect: 'postgres',
  dialectModule: pg,
  logging: false,
  dialectOptions: {
    ssl: isProduction ? { require: true, rejectUnauthorized: false } : false
  },
  // IMPORTANT: pas de pool pour √©viter MaxClientsInSessionMode pendant build/one-shot
  pool: false
};

const sequelize = process.env.DATABASE_URL
  ? new Sequelize(process.env.DATABASE_URL, baseOptions)
  : new Sequelize(
      process.env.DB_NAME || 'postgres',
      process.env.DB_USER || 'postgres',
      process.env.DB_PASSWORD,
      {
        host: process.env.DB_HOST,
        port: process.env.DB_PORT || 5432,
        ...baseOptions
      }
    );

// D√©finition du mod√®le Utilisateur directement
const Utilisateur = sequelize.define('Utilisateur', {
  id: {
    type: Sequelize.UUID,
    defaultValue: Sequelize.UUIDV4,
    primaryKey: true
  },
  username: {
    type: Sequelize.STRING(100),
    allowNull: false
  },
  email: {
    type: Sequelize.STRING(255),
    allowNull: false,
    unique: true
  },
  password: {
    type: Sequelize.STRING(255),
    allowNull: false
  },
  role: {
    type: Sequelize.STRING(20),
    defaultValue: 'user'
  }
}, {
  tableName: 'utilisateur',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  hooks: {
    beforeCreate: async (user) => {
      if (user.password) {
        user.password = await bcrypt.hash(user.password, 12);
      }
    },
    beforeUpdate: async (user) => {
      if (user.changed('password')) {
        user.password = await bcrypt.hash(user.password, 12);
      }
    }
  }
});

async function connectWithRetry(maxRetries = 3, delayMs = 1500) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`‚è≥ [CREATE-ADMIN] Connexion DB (tentative ${attempt}/${maxRetries})...`);
      await sequelize.authenticate();
      console.log('‚úÖ [CREATE-ADMIN] Connexion DB OK');
      return;
    } catch (err) {
      console.error(`‚ùå [CREATE-ADMIN] √âchec tentative ${attempt}:`, err.message);
      if (attempt === maxRetries) throw err;
      await new Promise(r => setTimeout(r, delayMs));
    }
  }
}

export async function createAdmin() {
  try {
    console.log('üöÄ [CREATE-ADMIN] D√©but du script de cr√©ation admin');
    console.log('üîç [CREATE-ADMIN] Variables d\'environnement:');
    console.log('  - NODE_ENV:', process.env.NODE_ENV);
    console.log('  - VERCEL:', process.env.VERCEL);
    console.log('  - DATABASE_URL d√©fini:', Boolean(process.env.DATABASE_URL));
    console.log('  - DB_HOST:', process.env.DB_HOST || '(non d√©fini)');
    
    try {
      await connectWithRetry(3, 1500);
      // Cr√©er l'admin par d√©faut
      await createAdminDefault();
    } catch (error) {
      console.error('‚ùå [CREATE-ADMIN] Erreur de connexion √† la base de donn√©es:', error.message);
      console.error('‚ùå [CREATE-ADMIN] Stack trace:', error.stack);
    } finally {
      await sequelize.close();
      console.log('üîå [CREATE-ADMIN] Connexion ferm√©e');
    }
  } catch (error) {
    console.error('‚ùå [CREATE-ADMIN] Erreur lors de la cr√©ation de l\'administrateur:', error.message);
    console.error('‚ùå [CREATE-ADMIN] Stack trace:', error.stack);
  }
}

async function createAdminDefault() {
  try {
    console.log('üîç [CREATE-ADMIN] V√©rification de l\'existence d\'un admin...');
    
    const existingAdmin = await Utilisateur.findOne({
      where: { role: 'admin' }
    });

    if (existingAdmin) {
      console.log('‚ö†Ô∏è  [CREATE-ADMIN] Un administrateur existe d√©j√†:', existingAdmin.email);
      console.log('üîÑ [CREATE-ADMIN] Mise √† jour des informations de l\'admin existant...');
      await existingAdmin.update({
        username: 'Lawi Salim',
        email: 'lawi@gmail.com',
        password: '123456',
        role: 'admin'
      });
      console.log('‚úÖ [CREATE-ADMIN] Administrateur mis √† jour avec succ√®s');
    } else {
      console.log('üî® [CREATE-ADMIN] Cr√©ation d\'un nouvel admin...');
      const admin = await Utilisateur.create({
        username: 'Lawi Salim',
        email: 'lawi@gmail.com',
        password: '123456',
        role: 'admin'
      });
      console.log('‚úÖ [CREATE-ADMIN] Administrateur cr√©√©:', admin.id);
    }

    console.log('\nüîê [CREATE-ADMIN] Connexions par d√©faut:');
    console.log('Email: lawi@gmail.com');
    console.log('Mot de passe: 123456');
    console.log('‚ö†Ô∏è  [CREATE-ADMIN] Changez le mot de passe apr√®s la premi√®re connexion');

  } catch (error) {
    console.error('‚ùå [CREATE-ADMIN] Erreur lors de la cr√©ation de l\'administrateur:', error.message);
    console.error('‚ùå [CREATE-ADMIN] Stack trace:', error.stack);
    if (error.name === 'SequelizeUniqueConstraintError') {
      console.log('üìß [CREATE-ADMIN] Un utilisateur avec cet email existe d√©j√†');
    } else if (error.name === 'SequelizeValidationError') {
      console.log('‚ùå [CREATE-ADMIN] Erreur de validation:', error.errors.map(e => e.message).join(', '));
    }
  } finally {
    // Fermeture g√©r√©e plus haut
  }
}

// Ex√©cuter le script si lanc√© directement
if (import.meta.url === `file://${process.argv[1]}`) {
  createAdmin();
}

export default createAdmin;